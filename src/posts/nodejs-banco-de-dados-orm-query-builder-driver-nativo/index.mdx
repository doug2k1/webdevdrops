---
title: 'Node.js e Banco de Dados: ORM, Query Builder, driver nativo'
date: '2020-06-12'
categories:
  - 'Node.js'
tags:
  - 'banco-de-dados'
  - 'nodejs'
coverImage: '/nodejs-banco-de-dados-orm-query-builder-driver-nativo/images/nodejs-database.jpg'
---

E a√≠, pessoal! Existem diferentes formas de se comunicar com banco de dados em **Node.js**, com diferentes n√≠veis de abstra√ß√£o: **driver nativo**, **query builder** e **ORM**. Neste post vou mostrar exemplos e as diferen√ßas entre elas.

<PostImage
  src="/nodejs-banco-de-dados-orm-query-builder-driver-nativo/images/nodejs-database-1024x576.jpg"
  width="1024"
  height="576"
  alt="Node.js e Banco de Dados: ORM, Query Builder, driver nativo"
/>

Estes padr√µes existem em v√°rias linguagens, mas vou mostrar exemplos em **Node.js**, acessando um banco de dados **[PostgreSQL](https://www.postgresql.org/)**.

## Driver nativo

Este √© o n√≠vel mais baixo, ou seja, mais pr√≥ximo do banco de dados. Voc√™ se conecta ao banco de dados, escreve **_queries_ SQL** em forma de _string_ e manda o banco executar. A execu√ß√£o das _queries_ √© uma opera√ß√£o ass√≠ncrona, portanto retornam uma **[Promise](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Promise)**.

Para trabalhar com **PostgreSQL** neste n√≠vel em Node.js a biblioteca mais popular √© o **[node-postgres (pg)](https://node-postgres.com/)**. Veja um exemplo a seguir.

Conex√£o com o banco:

```javascript
const { Client } = require('pg')

const client = new Client({
  user: 'dbuser',
  host: 'localhost',
  database: 'mydb',
  password: '123456',
  port: 5432,
})

await client.connect()
```

Inserindo um registro:

```javascript
await client.query('INSERT INTO users(name, email) VALUES($1, $2)', [
  'PG User',
  'pg@email.com',
])
```

Buscando o mesmo registro atrav√©s do email:

```javascript
const res = await client.query("SELECT * FROM users WHERE email='pg@email.com'")

console.log(res.rows)
/*
[
  {
    id: '4ea4aedd-9d76-44ad-906d-c24a1845ffae',
    name: 'PG User',
    email: 'pg@email.com'
  }
]
*/
```

## Query builder

Um n√≠vel de abstra√ß√£o acima est√° o **query builder**. A principal diferen√ßa √© que aqui voc√™ escreve as _queries_ programaticamente, usando fun√ß√µes, e a biblioteca se encarrega de gerar a _query_ nativa.

Uma vantagem desta abordagem √© que a biblioteca trata poss√≠veis diferen√ßas de sintaxe entre diferentes bancos de dados. Isso permite que voc√™ troque o banco de sua aplica√ß√£o com mais facilidade, fazendo pouca ou nenhuma altera√ß√£o no c√≥digo.

Uma das bibliotecas de query builder mais populares no Node.js √© a **[Knex](http://knexjs.org/)**. Veja abaixo como ela funciona.

Conex√£o com o banco:

```javascript
const knex = require('knex')
const config = require('../../knexfile.js').development
const db = knex(config)
```

O **Knex** recomenda colocar as configura√ß√µes de conex√£o em um arquivo `knexfile.js`, separadas por ambiente. Isto permite separar e gerenciar melhor o banco de desenvolvimento, testes e produ√ß√£o. Voc√™ pode at√© usar diferentes bancos por ambiente (**[SQLite](https://www.sqlite.org/index.html)** em desenvolvimento e **[PostgreSQL](https://www.postgresql.org/)** em produ√ß√£o, por exemplo).

Inserindo um registro:

```javascript
await db('users').insert({ name: 'Knex User', email: 'knex@email.com' })
```

Buscando o registro:

```javascript
const rows = await db.from('users').select().where({ email: 'knex@email.com' })

console.log(rows)
/*
[
  {
    id: '66b9c3ea-8270-4a73-bf12-aed96434ebcf',
    name: 'Knex User',
    email: 'knex@email.com'
  }
]
*/
```

Veja que em nenhum momento escrevemos _queries_ SQL nativas. Usamos apenas fun√ß√µes e objetos para construir a _query_.

O **Knex** at√© permite escrever queries nativas para os casos que isso seja necess√°rio.

Outra funcionalidade que bibliotecas neste n√≠vel j√° oferecem s√£o as **_[migrations](https://en.wikipedia.org/wiki/Schema_migration)_**, que s√£o mecanismos para registrar as altera√ß√µes feitas na estrutura do banco durante o projeto (adi√ß√£o, remo√ß√£o ou altera√ß√£o de colunas ou tabelas), permitindo "voltar no tempo" e desfazer alguma altera√ß√£o, ou aplicar as altera√ß√µes em um banco novo.

## ORM

**Object-Relational Mapping** (Mapeamento Objeto-Relacional), como o nome implica, √© um padr√£o onde se mapeia a estrutura relacional do banco em objetos na linguagem em quest√£o. Tabelas viram objetos, linhas viram atributos do objeto e rela√ß√µes entre tabela se transformam em rela√ß√µes entre objetos. Este √© o n√≠vel mais alto de abstra√ß√£o. Voc√™ n√£o precisa nem pensar em _queries_ SQL. Mas toda abstra√ß√£o tem seu pre√ßo, como falarei mais embaixo.

Algumas ferramentas fazem este mapeamento de forma mais autom√°tica, analisando a estrutura do banco, outras exigem que voc√™ o fa√ßa manualmente.

A biblioteca **ORM** mais popular no Node.js √© a **[Sequelize](https://sequelize.org/)**.

Para trabalhar com nossa tabela `users`, precisamos fazer o mapeamento dela com uma classe `User`. Na sintaxe do **Sequelize** fica assim:

```javascript
const User = sequelize.define(
  'user',
  {
    name: {
      type: Sequelize.STRING,
      allowNull: false,
    },
    email: {
      type: Sequelize.STRING,
      allowNull: false,
    },
  },
  { timestamps: false }
)
```

Uma facilidade do **Sequelize** √© que ele permite definir a classe no JS antes e usar o comando `sync` para alterar ou criar a estrutura no banco para sincronizar com o objeto.

Com o mapeamento definido, veja como ficam as opera√ß√µes.

Inserindo um registro:

```javascript
const user = await User.create({
  name: 'Sequelize User',
  email: 'sequelize@email.com',
})
```

O m√©todo `create` vai fazer duas opera√ß√µes: criar uma inst√¢ncia da classe `User` e salvar os dados no banco. Voc√™ tamb√©m pode fazer estas opera√ß√µes separadamente:

```javascript
// cria a inst√¢ncia
const user = User.build({
  name: 'Sequelize User',
  email: 'sequelize@email.com',
})

// persiste no banco
await user.save()
```

Buscando o registro:

```javascript
const user = await User.findOne({ where: { email: 'sequelize@email.com' } })

console.log(user.toJSON())
/*
{
  id: 'ef5659de-9d35-4bff-a435-5b9679c914e3',
  name: 'Sequelize User',
  email: 'sequelize@email.com'
}
*/
```

Veja que o m√©todo est√°tico `findOne` (assim como os outros m√©todos de consulta) retorna um objeto da classe `User`. Para exibir como JSON precisei usar o m√©todo `toJSON()`.

Outra abstra√ß√£o que um **ORM** faz √© sobre as rela√ß√µes entre entidades. Vamos supor que no nosso exemplo um **usu√°rio** possa ter v√°rios **posts** relacionados a ele. No **Sequelize**, na hora de buscar um usu√°rio eu posso dizer para ele fazer uma busca "gulosa" (_eager loading_) e j√° trazer tamb√©m os posts. Ficaria assim:

```javascript
const user = await User.findOne({
  where: { email: 'sequelize@email.com' },
  include: Post,
})
```

Com isso, o objeto `user` teria um atributo `user.posts` onde eu teria acesso aos posts daquele usu√°rio (como um array de objetos da classe `Post`).

Por fim, vale ressaltar que o **Sequelize** tamb√©m tem suporte a **_migrations_**.

Aqui no blog temos um outro post com um exemplo mais completo de uso do **Sequelize** em uma aplica√ß√£o:

**[Fullstack com Node.js, React e GraphQL‚Ää ‚Äì 3: PostgreSQL e Sequelize](/fullstack-node-react-graphql-postgresql-sequelize-11e646979b27/)**

## E a√≠? Qual √© o melhor?

A resposta √© o famoso **depende**.

O driver nativo √© mais indicado para casos espec√≠ficos, por exemplo, se voc√™ estiver desenvolvendo uma biblioteca (seu pr√≥prio **query builder** ou **ORM**). O **Knex** e o **Sequelize** usam as libs nativas por tr√°s.

Voc√™ pode pensar que o **ORM** √© melhor, pois abstrai mais os detalhes do banco. Mas como comentei acima, toda abstra√ß√£o tem seu pre√ßo.

### Performance

Uma biblioteca **ORM** visa facilitar a vida do desenvolvedor e ser flex√≠vel para atender v√°rios contextos diferentes. Em alguns casos, a _query_ gerada pela biblioteca pode n√£o ser t√£o eficiente quanto uma _query_ feita manualmente, principalmente quando envolve relacionamento. Alguns cuidados devem ser tomados para se evitar estes problemas.

### Esconder a tecnologia por tr√°s

Este √© justamente o objetivo de uma abstra√ß√£o, certo? Esconder os detalhes e apresentar uma forma mais amig√°vel para se trabalhar.

**Sim, mas o problema acontece quando o desenvolvedor pula etapas e usa uma abstra√ß√£o sem entender o que aquilo abstrai, a tecnologia por tr√°s.**

A gente v√™ o tempo todo: desenvolvedores aprendendo um framework JavaScript, sem aprender o JavaScript, ou aprendendo a usar um ORM, sem compreender como um banco de dados funciona.

Como saber se meu ORM est√° gerando uma **_query_ SQL** ineficiente seu eu n√£o sei nada sobre **SQL**?

Al√©m do mais, conhecer a tecnologia base me ajuda a escolher a melhor abstra√ß√£o e se eu preciso trocar de uma biblioteca pra outra o aprendizado vai ser mais r√°pido, pois a base √© a mesma.

## Conclus√£o

Aqui tem um c√≥digo com os tr√™s exemplos, caso queira experimentar: [https://github.com/doug2k1/nodejs-database](https://github.com/doug2k1/nodejs-database)

Espero que este post tenha sido √∫til. Se gostou, compartilhe nas suas redes sociais pra dar aquela for√ßa! üòâ
