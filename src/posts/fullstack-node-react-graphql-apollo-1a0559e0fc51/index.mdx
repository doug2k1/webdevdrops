---
title: 'Fullstack com Node.js, React e GraphQL‚Ää - 6: Servidor GraphQL'
date: '2018-04-21'
categories:
  - 'Full Stack'
tags:
  - 'full-stack'
  - 'graphql'
  - 'nodejs'
  - 'react'
coverImage: '/fullstack-node-react-graphql-apollo-1a0559e0fc51/images/fullstack-6-1.png'
---

E a√≠, pessoal! Neste sexto post da s√©rie [**Fullstack com Node.js, React e GraphQL**](/fullstack-node-react-graphql-introducao-2c2f18c757c4) vamos adicionar o **GraphQL** no servidor usando [**Apollo Server**](https://www.apollographql.com/docs/apollo-server/).

<PostImage
  src="/fullstack-node-react-graphql-apollo-1a0559e0fc51/images/fullstack-6-1-1024x558.png"
  width="1024"
  height="558"
  alt=""
/>

## GraphQL

[**GraphQL**](http://graphql.org/) √© uma linguagem de consulta (_query language_) para APIs que permite ao cliente descrever exatamente os dados que quer receber, e tamb√©m um conjunto de tecnologias que permite ao servidor descrever os dados dispon√≠veis e entregar estes dados, que podem ser buscados de m√∫ltiplas fontes (bancos de dados, APIs REST, outros servidores GraphQL).

Para ilustrar, veja um exemplo de query e o retorno do servidor:

<PostImage
  src="/fullstack-node-react-graphql-apollo-1a0559e0fc51/images/fullstack-6-2-1024x672.png"
  width="1024"
  height="672"
  alt=""
/>

Eu pedi pelas corretoras, campos id e nome, e dentro de cada corretora trazer seus investimentos, apenas campo nome. Esta √© a parte **QL** do nome (_query language_).

### E o¬†grafo?

A parte **Graph** do nome vem do fato que toda busca percorre um **grafo**.

> **Grafo** √© uma estrutura formada por **v√©rtices** (ou pontos ou n√≥s) e **arestas** (ou linhas) que ligam os v√©rtices.

Para ilustrar, veja como ficaria o grafo que representa nossa aplica√ß√£o. Destacado em laranja est√° o caminho percorrido pela _query_ acima.

<PostImage
  src="/fullstack-node-react-graphql-apollo-1a0559e0fc51/images/fullstack-6-3.png"
  width="888"
  height="618"
  alt=""
/>

Grafo com a representa√ß√£o de nossos modelos e suas rela√ß√µes.

No **GraphQL** sempre temos um n√≥ especial, chamado _Query_ (ou ponto de entrada, _root query_, _entrypoint_, _root type_) que √© por onde toda consulta deve iniciar.

No nosso exemplo, a partir da√≠ a consulta pode requisitar um ou mais **Brokers** ou **Investments**, e sequencialmente ir seguindo as arestas e pedindo dados de outros modelos relacionados. Essa estrutura, e o que pode ou n√£o ser pedido ser√° definida por n√≥s, quando criarmos nosso **schema**.

## Apollo

[**Apollo**](https://www.apollographql.com/) √© uma plataforma para desenvolvimento com GraphQL composta por:

- [**Apollo Client**](https://www.apollographql.com/client): facilita a integra√ß√£o do _frontend_ com o servidor GraphQL, possuindo bibliotecas para os principais frameworks JS (React, Vue, Angular) e plataformas mobile nativas (Android e iOS).
- [**Apollo Engine**](https://www.apollographql.com/engine): fornece ferramental auxiliar para infraestrutura como _caching_, tratamento de erros e rastreamento de performance.
- [**Apollo Server**](https://www.apollographql.com/server): bibliotecas que auxiliam na cria√ß√£o do servidor. Vamos us√°-lo nesta parte do projeto.

### Schema

A primeira coisa que precisamos pensar √© na forma dos dados que ser√£o disponibilizados. Como j√° temos nossos modelos definidos, vamos expor o que poder√° ser consultado atrav√©s do GraphQL (montar aquele grafo que vimos acima).

O **schema** √© como se fosse um contrato entre o fornecedor e o consumidor dos dados (ou entre o _server_ e o _client_).

### Ponto de¬†entrada

Vamos criar nosso schema em _src/graphql/schema.graphql_, come√ßando pela _root query:_

```graphql
type Query {
  brokers(limit: Int): [Broker]
  broker(id: ID!): Broker
  investments(limit: Int): [Investment]
  investment(id: ID!): Investment
}
```

Cada atributo possui um nome e um tipo de retorno e, opcionalmente, pode receber par√¢metros. A sintaxe se assemelha a assinatura de fun√ß√µes em linguagens fortemente _tipadas_.

A¬†`!` como em `id: ID!` significa obrigatoriedade daquele valor.

`[]` como em `[Broker]` significa uma lista de objetos daquele tipo.

Resumindo, nosso ponto de entrada permite buscar por um `broker` ou um `investment`, informando o _id_ como par√¢metro, ou por uma lista de `brokers` ou `investments`, opcionalmente informando um limite.

### Demais n√≥s

Na sequ√™ncia descrevemos os n√≥s que representam nossos modelos, ficando assim:

```graphql
scalar Date

type Query {
  brokers(limit: Int): [Broker]
  broker(id: ID!): Broker
  investments(limit: Int): [Investment]
  investment(id: ID!): Investment
}

type Broker {
  id: ID!
  name: String!
  investments: [Investment]
}

type Investment {
  id: ID!
  name: String!
  broker: Broker
  balanceUpdates(limit: Int, order: [[String]]): [BalanceUpdate]
  transactions: [Transaction]
}

type BalanceUpdate {
  id: ID!
  amount: Float!
  date: Date!
}

type Transaction {
  id: ID!
  amount: Float!
  date: Date!
}
```

Para mais detalhes, veja a documenta√ß√£o sobre a defini√ß√£o de _schema_: [http://graphql.org/learn/schema/](http://graphql.org/learn/schema/)

### Resolvers

Definido o **schema** e a forma do nosso grafo, a aplica√ß√£o ainda n√£o sabe como buscar os dados para atender as _queries_. Vamos resolver isso com **resolvers**. ü•ÅüòÅ

Vamos criar o arquivo _src/graphql/resolvers.js_:

```javascript
const { GraphQLString } = require('graphql')
const { Broker, Investment, BalanceUpdate, Transaction } = require('../models')

module.exports = {
  Query: {
    brokers: (obj, args) => Broker.all(args),
    broker: (obj, { id }) => Broker.findById(id),
    investments: (obj, args) => Investment.all(args),
    investment: (obj, { id }) => Investment.findById(id),
  },
  Investment: {
    broker: (obj) => Broker.findOne({ where: { id: obj.BrokerId } }),
    balanceUpdates: (obj, args) =>
      BalanceUpdate.all({ where: { InvestmentId: obj.id }, ...args }),
    transactions: (obj) => Transaction.all({ where: { InvestmentId: obj.id } }),
  },
  Broker: {
    investments: (obj) => Investment.findAll({ where: { BrokerId: obj.id } }),
  },
  Date: GraphQLString,
}
```

Este arquivo exporta um objeto JS onde para cada navega√ß√£o de um n√≥ a outro do grafo definimos uma fun√ß√£o que ir√° buscar os dados referente √†quela parte da _query_ (E esta busca pode ser em m√∫tiplos locais: banco de dados, API REST ou at√© outro servidor GraphQL).

Por exemplo, se estou em **Investimento** e quero buscar a **Corretora** daquele investimento, tenho:

```javascript
Investment: {
  broker: (obj) => Broker.findOne({ where: { id: obj.BrokerId } })
}
```

O primeiro argumento da fun√ß√£o, `obj`, √© o objeto que representa aquele n√≥. Assim, para buscar o **Broker** usamos `Broker.findOne` passando o atributo `BrokerId` do **Investment**.

Para _queries_ que aceitam par√¢metros, estes s√£o passados no segundo argumento da fun√ß√£o. Exemplo:

```javascript
Query: {
    brokers: (obj, args) => Broker.all(args),
    broker: (obj, { id }) => Broker.findById(id)
}
```

### Endpoint de consultas

Temos o _schema_, que descreve as _queries_, e os _resolvers_ que buscam os dados. Vamos juntar as duas partes e criar nosso _endpoint_ de consultas, que √© o endere√ßo onde o frontend da aplica√ß√£o vai bater para trazer os dados para a tela. Aqui vamos usar o **Apollo Server**:

```javascript
const { graphqlExpress } = require('apollo-server-express')
const { makeExecutableSchema } = require('graphql-tools')
const { importSchema } = require('graphql-import')
const resolvers = require('./graphql/resolvers')

const setup = (app) => {
  const schema = makeExecutableSchema({
    typeDefs: importSchema('src/graphql/schema.graphql'),
    resolvers,
  })

  // graphql endpoint
  app.use('/graphql', graphqlExpress({ schema }))
}

module.exports = setup
```

Usei a fun√ß√£o `makeExecutableSchema` do m√≥dulo **graphql-tools** para criar um _schema_ ‚Äúexecut√°vel‚Äù a partir do nosso _schema_ e _resolvers_.

Para importar o arquivo _schema.graphql_ usei o m√≥dulo **graphql-import**, j√° que n√£o √© um arquivo JS e n√£o pode ser importado diretamente.

Com o _schema_ ‚Äúexecut√°vel‚Äù, uso a fun√ß√£o `graphqlExpress`, do m√≥dulo **apollo-server-express**, que √© um _middleware_ do **Express**, para definir o _endpoint_ no caminho _/graphql._

Para organiza√ß√£o eu deixei este c√≥digo em um arquivo separado, _setupGraphQL.js_, que exporta uma fun√ß√£o de setup, que √© usada no _src/index.js_ esta forma:

```javascript
const setupGraphQL = require('./setupGraphQL')

const app = express()

setupGraphQL(app)
```

Agora precisamos testar nossas consultas. Ah, se tivesse uma esp√©cie de _playground_ onde pud√©ssemos inserir _queries_ e ver os resultados‚Ä¶

Mas tem! √â o‚Ä¶

## GraphiQL

O **GraphiQL** √© uma interface web que permite inserir _queries_, possui autocomplete e uma documenta√ß√£o com todas as _queries_ e campos poss√≠veis. Tudo gerado a partir do nosso _schema_.

<PostImage
  src="/fullstack-node-react-graphql-apollo-1a0559e0fc51/images/fullstack-6-4-1024x652.png"
  width="1024"
  height="652"
  alt=""
/>

Interface do¬†GraphiQL

Para habilitar esta interface basta usar o _middleware_ `graphiqlExpress` do **Apollo**, informando o _endpoint_ de consultas.

```javascript
const { graphqlExpress, graphiqlExpress } = require('apollo-server-express')

app.use('/graphiql', graphiqlExpress({ endpointURL: '/graphql' }))
```

Assim, basta rodar o servidor local e acessar **http://localhost:5000/graphiql** para explorar seu servidor **GraphQL**.

## Resultado final

O c√≥digo do projeto at√© este ponto est√° em: [https://github.com/doug2k1/my-money/tree/v5.0.0](https://github.com/doug2k1/my-money/tree/v5.0.0)

## No pr√≥ximo¬†cap√≠tulo

Na pr√≥xima parte vamos implementar **autentica√ß√£o** para proteger nosso _endpoint_ de consultas contras bisbilhoteiros.

_Stay tuned!_

## Feedbacks?

E a√≠, o que est√° achando at√© agora? Algo que precisa melhorar?
